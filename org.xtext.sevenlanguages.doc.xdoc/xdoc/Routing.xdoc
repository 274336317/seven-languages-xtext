chapter:routing[Http Routing]

section:routing_motivation[The Problem]

There are several different frameworks out there like link[https://github.com/playframework/Play20/wiki/ScalaRouting][Play]
to support HttpRoutes.
Normally they are defined in a special format in a separated central file. In most of the cases there is no tooling except a normal text/XML editor. 
The only way to decide which route matches is the URL with different wildcards and placeholders. 
The order of the routes defined in the file is important to decide which matches first. There is no support to access parts of the URL while the mapping is done.
In most of the cases you might want to have full control via expressions to decide which action should be called. 
Normally concrete classes are used directly in the route definition to point to an action that should be triggered. That's not really reusable in different scenarios and dependency injection is what you would really like to use.

section:routing_solution[A Solution With Xtext]

In this project, we have created a small DSL base on link[http://www.xtext.org][Xtext] that allows to create routing with full support of expressions and access to the URL while the routing is done.
The result is a javax.servlet.http.HttpServlet that has methods for the different routes with optional conditions and link[http://code.google.com/p/google-guice][Guice] bindings. Depending on the order in the file, the pattern and the conditions the respective method is called. 
Eventually, we do only have a single javax.servlet.http.HttpServlet containing the logic for routing implemented in Java. 
To define routes you'll have to create a file with the extension '.route'. The first part of a route defines the type (GET, POST, PUT, DELETE or HEAD) of the route and the pattern.
code[GET /client/foo/:id/bar/:rest* ...]
ul[
	item[code[:id] means a placeholder for a word]
	item[code[:rest*] means match everything to the rest of the url]
]
Then you have the possibility to define a condition like:
code[GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ...]
Here you have access to id and rest statically typed to String. The servlet will provide the value of the placeholder or wildcard when the mapping takes place. 
An optional annotated Guice-key could be used after the condition or pattern to get an instance of that type/interface and trigger an operation. 
code[GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass->doSomething(Integer::parseInt(id))]
You'll see that there is access to all features of the bound type/interface with access to the placeholders or wildcard values from the URL.
If you want to call static methods there is no need for a Guice-key. 
code[GET /client/foo/:id/bar/:rest* when id == "42" and rest == "xtext/rocks" ActionClass::doSomethingStatic(id)]
In both cases you have the possibility to feed the methods with an expression.

If you have ever seen a HttpServlet you might know that there is exactly one method for each type (GET,
POST, ...). Within these methods we'll have to call our routing logic with access to the request and response. 
A route describes a pattern, a condition, a Guice-key and a call of an action. So a pattern should be translated to a field as regular expression. This helps to match the URL and extract the values out of
the given URL from the request. 
A condition should be a method with a boolean returntype where the request and the values of the variables from
the URL-pattern are handled in as parameters. 
The guice-key should be a field annotated with whatever is specified by
the user and @Inject to tell Guice to inject an implementation here. 
There is one more need for a method to wrap the action call with same parameters as the condition.
Now we have all stuff to fill in our logic inside of the global method of the HttpServelet. First of
all we have to match the URL, extract the values for the variables and establish local variables for
that. If there is a condition we have to establish a guard for the action call. Only when the pattern
matches the URL and the condition is true the call should be triggered. Otherwise a following route should
be evaluated in the same way.

section2:routing_statistics[Some Stats]

table[
tr[td[Language name]td[HttpRouting]]
tr[td[Xtext Grammar]td[39 LOC, 8 rules, 1 Enum]]
tr[td[Xtext extensions]td[6 classes]]
tr[td[Execution]td[Java code generator]]
tr[td[Hardest Part]td[Handle regular expressions :-)]]
]

section:routing_running[Running the Example]

You'll need Eclipse 3.5 or higher, Xtext 2.3 and Xtend 2.3. The Servelet-API on the class path of your project.

section:routing_details[The Solution in Detail]

section2:routing_grammar[Grammar]

The Routing DSL extends org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations to make use of expressions
predefined by link[http://www.eclipse.org/Xtext/#xbase][Xbase] plus support for Annotations.
code[grammar org.xtext.httprouting.Route with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
]
code[
Import:
	'import' importedType=\[types::JvmType|QualifiedName\];
]
The Route DSL defines imports by using crossreferences. This makes it possible to use contentassist here
and it is clear that the imported type exist.
code[
Route:
	type=Type url=URL condition=Condition? (key=Key call=RouteFeatureCall | call=XFeatureCall);
	
URL:
	{URL} "/" (ID ("." ID)? | variables+=Variable) ("/" (ID ("." ID)? | variables+=Variable))*;
	
Variable:
	":" name=ID (wildcard?="*")?;
	
Condition:
	"when" expression=XExpression;
	
Key:
	annotations+=XAnnotation? type=JvmTypeReference;
]
A Route has a type followed by an URL-pattern that can define variables. A variable could be a placeholder
':id' or a wildcard ':name*'. After the URL-pattern matches an optional condition can point out if the
route matches. Here you'll have the full support Xbase offers with access to the defined variables. 

One special thing here is that we can point to an action-implementation in different ways. 
One is to define a guice-key with an optinal annotation to specialize a
binding and access an available feature of the type directly after that. The other is to have a static
method call on a type. The difference between RouteFeatureCall and XFeatureCall is that RouteFeatureCall
does not allow a static method call.If you would like to see the difference on a grammar level please
compare XFeatureCall and RouteFeatureCall with each other.

section2:routing_inferrer[Translation to Java]

section2:routing_additons[Additional Aspects]

With the Grammar and the inferrer mentioned in the sections above the DSL is funtional and does excatly
what we want but there are several things we should customize to have a nice tool-support.
ul[
	item[First of all there are several things we do not want to have in the contentassist] 
	item[The outline is really ugly when the elements do not have a name]
	item[There is a need for validation in the URL-pattern defintion]
]
So lets concentrate on the things in the contentassist. The inferred methods and fields have syntetic names
and from the context of a condition or an action call we do not want to see the inferred things at all.
The other thing is in case of a Guice-Key we introduce a parameter with the name 'it'. This means that
all features of the type behind it are visible without writing it in front of the call. Good thing but
we do not want it as itself in the contentassist.
So for that reason we have to customize the code and tweak the inferrer. All inferred fields and methods
are prefixed with an underscore so that we can filter out proposals with this prefix in org.xtext.httprouting.ui.contentassist.RouteProposalProvider.
code[
	@Override
	protected Predicate<IEObjectDescription> getFeatureDescriptionPredicate(ContentAssistContext contentAssistContext) {
		if (contentAssistContext.getPrefix().startsWith("_"))
			return super.getFeatureDescriptionPredicate(contentAssistContext);
		final Predicate<IEObjectDescription> delegate = super.getFeatureDescriptionPredicate(contentAssistContext);
		return new Predicate<IEObjectDescription>() {
			public boolean apply(IEObjectDescription input) {
				return !input.getName().getFirstSegment().startsWith("_") && delegate.apply(input);
			}
		};
	}]

To filter out 'it':
code[
	public void completeRouteFeatureCall_Feature(EObject model,
			Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		
		Function<IEObjectDescription, ICompletionProposal> proposalFactory = getProposalFactory(getFeatureCallRuleName(), context);
		IScope scope = new FilteringScope(getScopeProvider().createSimpleFeatureCallScope(model, XbasePackage.Literals.XABSTRACT_FEATURE_CALL__FEATURE, context.getResource(), false, -1), new Predicate<IEObjectDescription>() {
			public boolean apply(IEObjectDescription input) {
				return !input.getQualifiedName().equals(XbaseScopeProvider.IT);
			}
		});
		getCrossReferenceProposalCreator().lookupCrossReference(scope, model, XbasePackage.Literals.XABSTRACT_FEATURE_CALL__FEATURE, acceptor, getFeatureDescriptionPredicate(context), proposalFactory);
	}]
	


section:routing_beyond[Beyond This Example]