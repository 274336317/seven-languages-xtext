chapter:mongo[MongoBeans]

link[http://www.mongodb.org][MongoDB] is a very popular document-based database management system. 
In mongoDB, database entries (AKA e[documents]) have fields, which are essentially e[(key, value)] pairs.
MongoDB is schema free, i.e. there are no rules which fields have to be defined and of what type they are.
This allows for very flexible and heterogenous data structures and maps perfectly with JSON. 

section:mongo_motivation[The Problem]

Java is statically typed: The available types, their field names and field types, are known and validated 
at compile time. The JavaBeans convention defines how instances can be manipulated. 

OTOH, the standard mongoDB Java driver reflects mongoDB's schema freeness by providing mongo documents as 
raw Java maps. This results in some major annoyances: First, you loose the benefit from Java's static typing. 
You can ask a codeRef[com.mongodb.DBObject] for the value of a specific field, but you cannot be sure 
that the returned codeRef[java.lang.Object] is of some expected type. As database entities are likely to 
play a major role in your application, having them implemented as a generic codeRef[com.mongodb.DBObject]
will likely result poorly readable and unsafe code. Second, additional behavior that would usually go into 
methods of your entity classes has to be defined by external helper classes. Third, constructing a graph of 
nested generic maps looks pretty bulky and inconventient in Java and breaks with the JavaBeans conventions.

section:mongo_solution[A Solution With Xtext]

In this project, we have created a small DSL e[mongoBeans] based on Xtext that allows to create basic 
entity classes that are backed by mongoDB objects but provide a statically typed JavaBeans API. Think of 
the language as a description how to map mongoDB documents to JavaBeans, in analogy to well known object 
relational mappers.

An example mongoBeans file looks like this:
code[mongoBeans][
import java.util.*

package org.musicdb {
    // a mongo bean
    Artist {
        String name    // single valued property
        Album* albums  // array property
        // an operation
        Iterable<Track> getOevre() {
            albums.map\[track\].flatten
        }
    }

    // another mongo bean
    Album {
        String title 
        int year 
        // inline definition of a mongo bean
        Track {        
            String title
            int seconds
        }* tracks
    }
}
]

From each e[MongoBean] definition a mongoBeans file, we generate a Java class that wraps a 
codeRef[com.mongodb.DBObject]. The class provides statically typed getter and setter methods for all 
defined e[MongoProperties]. In the implementation of these accessor methods we delegate to the wrapped
codeRef[com.mongodb.DBObject] and do all the casting and conversion work. For the code[Artist] in the 
above example, this would look like

code[Java][
public class Artist implements IMongoBean {

  private DBObject _dbObject;
  
  public DBObject getDbObject() {
    return this._dbObject;
  }

  ...
  
  public String getName() {
    return (String) _dbObject.get("name");
  }
  
  public void setName(final String name) {
     _dbObject.put("name", name);
  }
  ...
}
]
 
By generating Java code, the rest of the application can use a safe, statically typed and JavaBeans 
conformant API. In addition, e[MongoBeans] can define e[MongoOperations] which are translated to Java
methods. By using the expression library Xbase, we can use e[MongoProperties] as well as Java types 
inside the operations' bodies. 

section2:mongo_statistics[Some Stats]

table[
tr[td[Language name]td[mongoBeans]]
tr[td[Xtext Grammar]td[27 LOC, 9 rules]]
tr[td[Xtext extensions]td[6 classes]]
tr[td[Execution]td[Java code generator]]
tr[td[Runtime library]td[4 classes]]
tr[td[Hardest part]td[Finding a project name w/o politically incorrect connotation]]
]

section:mongo_running[Running the Example]

In addtion to the ref:common_requirements[common requirements], you need the 
link[http://www.mongodb.org/downloads][mongoDB implementation] for your platform. We have included 
the mongoDB Java driver from link[http://download.eclipse.org/tools/orbit/downloads/][Eclipse Orbit] 
in the code base. 

Import the projects into an Eclipse workspace and run the launch config 
e[Run (org.eclipse.xtext.mongobeans)]. Import the example plug-in into the new workspace and run 
code[MusicDBXtendTest] as a JUnit test.

section:mongo_details[The Solution in Detail]

section2:mongo_grammar[Grammar]

The complete mongoBenas grammar looks like this: 

code[Xtext][
grammar org.xtext.mongobeans.MongoBeans with org.eclipse.xtext.xbase.Xbase

generate mongoBeans "http://www.eclipse.org/xtext/mongobeans/MongoBeans"

MongoFile:
	elements+=AbstractElement*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

AbstractElement:
	Import | PackageDeclaration | MongoBean;

PackageDeclaration:
	'package' name=QualifiedName '{'
		elements+=AbstractElement*
	'}';

MongoBean:
	name=ValidID '{'
		features+=AbstractFeature*
	'}';

AbstractFeature:
	MongoOperation | MongoProperty;

MongoProperty:
	(type=JvmTypeReference | inlineType=MongoBean) (many?='*')? name=ValidID;

MongoOperation:
	=>(returnType=JvmTypeReference name=ValidID '(') 
		(parameters+=FullJvmFormalParameter (',' parameters+=FullJvmFormalParameter)*)? 
	')' 
	body=XBlockExpression;

QualifiedNameWithWildcard:
	QualifiedName (".*")?;
]

The grammar inherits from the grammar of code[Xbase] in order to allow references to Java elements and Xbase 
expressions. A e[MongoFile] contains any number of e[AbstractElements], which can be e[PackageDeclarations],
e[Imports] or e[MongoBeans]. e[Imports] use Xtext's naming convention code[importedNamespace] to automatically 
shorten qualified names of matching elements. Note that as opposed to Java, e[PackageDeclarations] can be nested.     
e[MongoBeans] define statically typed MongoProperties, which can be single-valued or array-valued denoted by an 
code[*] following the type name. The type of a e[MongoProperty] can also be defined inline. e[MongoBeans] can 
also define e[MongoOperations]. Instead of defining all possible expressions for the body of an operation, we 
leverage Xtext's expression language library Xbase. 

section2:mongo_inferrer[Translation to Java]

In the end, we want to generate Java code from our mongoBeans files. With Xbase, that means to map our
DSL concepts to Java concepts. This approach provides very detailed information and allows for better tooling
than traditional model-to-text code generation. It also enables mixing Java and DSL concepts, e.g. in
operation bodies.

The transformation is implemented in the codeRef[org.eclipse.xtext.mongobeans.jvmmodel.MongoBeansJvmModelInferrer].
It is written in the programming language link[http://www.xtend-lang.org][Xtend], which is Java-like
but has a far more convenient syntax.   




section2:mongo_additons[Additional Aspects]

Defining the type of a e[MongoProperty] inline requires to adapt the language infrastructure a bit:

ul[
item[the qualified name of a MongoBean should not contain the names of container MongoBeans or 
	MongoProperties (MongoQualifiedNameProvider).]
item[The Java driver for mongoDB cannot map all Java types to monogoDB types. To enforce that constraint, 
	we've added a MongoBeansJavaValidator. Note that we can use MongoBeans as plain Java types, because 
	we define a mapping for MongoBeans to Java classes.]
]
To improve the language visually, we've also tuned the outline and the icons a bit. 

section:mongo_beyond[Beyond This Example]